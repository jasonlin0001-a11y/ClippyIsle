{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/jasonlin/ClippyIsle/web/src/lib/firebase.ts"],"sourcesContent":["import { initializeApp, getApps, FirebaseApp } from 'firebase/app';\nimport { getAuth, Auth } from 'firebase/auth';\nimport { getFirestore, Firestore } from 'firebase/firestore';\nimport { getStorage, FirebaseStorage } from 'firebase/storage';\n\n// Firebase configuration using environment variables\nconst firebaseConfig = {\n  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\n  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\n  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\n  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\n  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,\n};\n\n// Check if we're in a browser or server environment with valid config\nconst isConfigValid = firebaseConfig.apiKey && firebaseConfig.projectId;\n\n// Initialize Firebase (avoid double initialization during hot reloads)\nlet app: FirebaseApp | undefined;\nlet auth: Auth | undefined;\nlet db: Firestore | undefined;\nlet storage: FirebaseStorage | undefined;\n\nif (isConfigValid) {\n  if (getApps().length === 0) {\n    app = initializeApp(firebaseConfig);\n  } else {\n    app = getApps()[0];\n  }\n\n  auth = getAuth(app);\n  db = getFirestore(app);\n  storage = getStorage(app);\n}\n\nexport { app, auth, db, storage };\n"],"names":[],"mappings":";;;;;;;;;;AAOU;AAPV;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;;;;AAEA,qDAAqD;AACrD,MAAM,iBAAiB;IACrB,MAAM;IACN,UAAU;IACV,SAAS;IACT,aAAa;IACb,iBAAiB;IACjB,KAAK;AACP;AAEA,sEAAsE;AACtE,MAAM,gBAAgB,eAAe,MAAM,IAAI,eAAe,SAAS;AAEvE,uEAAuE;AACvE,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AAEJ,IAAI,eAAe;IACjB,IAAI,IAAA,8KAAO,IAAG,MAAM,KAAK,GAAG;QAC1B,MAAM,IAAA,oLAAa,EAAC;IACtB,OAAO;QACL,MAAM,IAAA,8KAAO,GAAE,CAAC,EAAE;IACpB;IAEA,OAAO,IAAA,wKAAO,EAAC;IACf,KAAK,IAAA,kLAAY,EAAC;IAClB,UAAU,IAAA,8KAAU,EAAC;AACvB"}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///Users/jasonlin/ClippyIsle/web/src/context/AuthContext.tsx"],"sourcesContent":["'use client';\n\nimport { createContext, useContext, useEffect, useState, ReactNode, useMemo } from 'react';\nimport { User, onAuthStateChanged, signOut as firebaseSignOut } from 'firebase/auth';\nimport { doc, getDoc } from 'firebase/firestore';\nimport { auth, db } from '@/lib/firebase';\n\ninterface AuthContextType {\n  user: User | null;\n  isAdmin: boolean;\n  loading: boolean;\n  signOut: () => Promise<void>;\n}\n\nconst AuthContext = createContext<AuthContextType>({\n  user: null,\n  isAdmin: false,\n  loading: true,\n  signOut: async () => {},\n});\n\nexport function AuthProvider({ children }: { children: ReactNode }) {\n  const [user, setUser] = useState<User | null>(null);\n  const [isAdmin, setIsAdmin] = useState(false);\n  // If Firebase is not initialized, we're not loading\n  const [loading, setLoading] = useState(!!auth);\n\n  useEffect(() => {\n    // If Firebase is not initialized, don't set up the listener\n    if (!auth) {\n      return;\n    }\n\n    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {\n      setLoading(true);\n      \n      if (firebaseUser) {\n        setUser(firebaseUser);\n        \n        // Check if user is admin by checking admins collection\n        try {\n          if (db) {\n            const adminDocRef = doc(db, 'admins', firebaseUser.uid);\n            const adminDoc = await getDoc(adminDocRef);\n            setIsAdmin(adminDoc.exists());\n          } else {\n            setIsAdmin(false);\n          }\n        } catch (error) {\n          console.error('Error checking admin status:', error);\n          setIsAdmin(false);\n        }\n      } else {\n        setUser(null);\n        setIsAdmin(false);\n      }\n      \n      setLoading(false);\n    });\n\n    return () => unsubscribe();\n  }, []);\n\n  const signOut = async () => {\n    if (!auth) return;\n    \n    try {\n      await firebaseSignOut(auth);\n      setUser(null);\n      setIsAdmin(false);\n    } catch (error) {\n      console.error('Error signing out:', error);\n      throw error;\n    }\n  };\n\n  const value = useMemo(() => ({ user, isAdmin, loading, signOut }), [user, isAdmin, loading]);\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AAAA;AACA;AAAA;AACA;;;AALA;;;;;AAcA,MAAM,4BAAc,IAAA,8KAAa,EAAkB;IACjD,MAAM;IACN,SAAS;IACT,SAAS;IACT,SAAS,WAAa;AACxB;AAEO,SAAS,aAAa,EAAE,QAAQ,EAA2B;;IAChE,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,yKAAQ,EAAc;IAC9C,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAC;IACvC,oDAAoD;IACpD,MAAM,CAAC,SAAS,WAAW,GAAG,IAAA,yKAAQ,EAAC,CAAC,CAAC,iIAAI;IAE7C,IAAA,0KAAS;kCAAC;YACR,4DAA4D;YAC5D,IAAI,CAAC,iIAAI,EAAE;gBACT;YACF;YAEA,MAAM,cAAc,IAAA,mLAAkB,EAAC,iIAAI;sDAAE,OAAO;oBAClD,WAAW;oBAEX,IAAI,cAAc;wBAChB,QAAQ;wBAER,uDAAuD;wBACvD,IAAI;4BACF,IAAI,+HAAE,EAAE;gCACN,MAAM,cAAc,IAAA,yKAAG,EAAC,+HAAE,EAAE,UAAU,aAAa,GAAG;gCACtD,MAAM,WAAW,MAAM,IAAA,4KAAM,EAAC;gCAC9B,WAAW,SAAS,MAAM;4BAC5B,OAAO;gCACL,WAAW;4BACb;wBACF,EAAE,OAAO,OAAO;4BACd,QAAQ,KAAK,CAAC,gCAAgC;4BAC9C,WAAW;wBACb;oBACF,OAAO;wBACL,QAAQ;wBACR,WAAW;oBACb;oBAEA,WAAW;gBACb;;YAEA;0CAAO,IAAM;;QACf;iCAAG,EAAE;IAEL,MAAM,UAAU;QACd,IAAI,CAAC,iIAAI,EAAE;QAEX,IAAI;YACF,MAAM,IAAA,wKAAe,EAAC,iIAAI;YAC1B,QAAQ;YACR,WAAW;QACb,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,sBAAsB;YACpC,MAAM;QACR;IACF;IAEA,MAAM,QAAQ,IAAA,wKAAO;uCAAC,IAAM,CAAC;gBAAE;gBAAM;gBAAS;gBAAS;YAAQ,CAAC;sCAAG;QAAC;QAAM;QAAS;KAAQ;IAE3F,qBACE,6LAAC,YAAY,QAAQ;QAAC,OAAO;kBAC1B;;;;;;AAGP;GA9DgB;KAAA;AAgET,SAAS;;IACd,MAAM,UAAU,IAAA,2KAAU,EAAC;IAC3B,IAAI,CAAC,SAAS;QACZ,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;IANgB"}}]
}